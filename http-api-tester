#!/bin/bash

function print_usage {
  echo "Usage: http-api-tester <arguments> <test_case_directory>"
  echo "Arguments:"
  echo "  -c|--clean"
  echo "    delete previous run results"
  exit 1
}

# Parse command line arguments (http://stackoverflow.com/questions/192249/how-do-i-parse-command-line-arguments-in-bash)
while [[ $# -gt 1 ]]; do
  key="$1"

  case $key in
    -c|--clean)
    clean=1
    ;;
    *)
    print_usage
    ;;
  esac
  shift
done

test_case_directory=$1
test_date=$(date +"%Y-%m-%d")
test_time=$(date +"%T" | sed s/:/-/g)
test_timestamp="$test_date-$test_time"
if [ -z "$test_case_directory" ]; then
  print_usage
fi

if [ ! -d "$test_case_directory" ]; then
  echo "Test case directory $test_case_directory does not exist"
  exit 1
fi

suite_exit_code=0

function test {
  test_case=$1

  run_folder="$test_case/run-$test_timestamp"

  echo -e "\033[1m$run_folder\033[0m:"

  if [ ! -z "$clean" ]; then
    echo "  clean:"
    for test_result in $test_case/run-*; do
      command="rm -rf $test_result"
      echo "    - $command"
      $command
    done
  fi

  mkdir $run_folder 2> /dev/null
  actual_folder="$run_folder/actual"
  mkdir $actual_folder 2> /dev/null
  expected_folder="$run_folder/expected"
  cp -R $test_case/expected $expected_folder 2> /dev/null

  method=$(cat $test_case/method 2> /dev/null || echo "")
  if [ -z "$method" ]; then
    method_subcommand=""
  else
    method_subcommand="-X $method"
  fi

  url=$(cat $test_case/url 2> /dev/null || echo "")
  if [ -z "$url" ]; then
    url_subcommand="localhost"
  else
    url_subcommand="$url"
  fi

  request_data=$(cat $test_case/request-data 2> /dev/null || echo "")
  if [ -z "$request_data" ]; then
    request_data_subcommand=""
  else
    request_data_subcommand="-d @$test_case/request-data"
  fi

  if [ -r "$test_case/before" ]; then
    echo "  before:"
    $test_case/before
  fi

  base_command="curl -s $method_subcommand $request_data_subcommand $url_subcommand"
  echo "  command:"
  echo "    - $base_command"
  command="$base_command --write-out status-code:%{http_code}\n --output $actual_folder/response-data"
  $command > $actual_folder/response-curl

  function compare {
    local actual="$actual_folder/$1"
    local expected="$expected_folder/$1"
    cmp --silent $actual $expected
    local status=$?
    if [ $status -ne 0 ]; then
      echo -e "    - \033[0;31m$actual did not match $expected\033[0m" >&2
    else
      echo -e "    - \033[0;32m$actual matched $expected\033[0m"
    fi
    return $status
  }

  echo "  result:"
  if [ -r $expected_folder/response-data ]; then
    expectation_found=1
    if [ -r $actual_folder/response-data ]; then
      cat $actual_folder/response-data | jq . > $actual_folder/response-data.json
      cat $expected_folder/response-data | jq . > $expected_folder/response-data.json
      compare response-data.json
      local status=$?
      if [ ! "$status" = 0 ]; then
        suite_exit_code=$status
      fi
    else
      echo -e "    - \033[0;31m$actual_folder/response-data does not exist\033[0m" >&2
      suite_exit_code=1
    fi
  fi

  if [ -r $expected_folder/http-status ]; then
    expectation_found=1
    grep "^status-code:" $actual_folder/response-curl | cut -d: -f2 > $actual_folder/http-status
    compare http-status
    local status=$?
    if [ ! "$status" = 0 ]; then
      suite_exit_code=$status
    fi
  fi

  if [ -z $expectation_found ]; then
    echo -e "    - \033[0;33mno expectations found in $test_case/expected\033[0m"
  fi

  if [ -r "$test_case/after" ]; then
    echo "  after:"
    $test_case/after
  fi
}

for test_case in $test_case_directory/*; do
  [ -d "${test_case}" ] || continue
  test $test_case
done

exit $suite_exit_code
